#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Fri Mar 31 23:57:01 2017

@author: zhangchi
"""

#==============================================================================
# 高位更加重要，从高位向低位逐一判断
# example:
# 4(二进制100)，2(二进制010)，先判断最高位能否达到1
# step1. 计算过程是100&100=100，010&100=000，得到的俩结果100, 000 -->取出最高位的数字（1和0）
# （此处两个式子中的第二个100，是由前面确定的高位数字，再加上待确定的数字组成，
# 如：经过判断，我们确定了前三位能达到的最大值是101，后面几位（假设后面还有四位，那全部数字为1010000）
# 还没确定，然后可先设置第四位为1，再后面的全为0（即1011000），然后通过与关系，把所需要的高位数字取出来）
# step2. 俩结果再和100异或，判断异或的结果是否也在之前那一步的结果中
# step2 原理:
# if a ^ b = c (a,b分别为上面取出的最高位数字1，0（或者说是100，000），c为1(或者说是100，后两位都是0忽略))
# then a ^ c = b 
# example:
# 我们有俩数1101和0110，我们已经确定了最终结果前三位能达到的最大值为101，然后判断第四位到底是1还是0，
# 就先用1011和他们与，得到1001和0010，--->这里用与的原因是，我们先关注高位，通过与关系把想关注的位先取出来
# 然后我们判断0010和1001异或能不能达到1011，
# 这里很简单，只有俩个数，我们直接异或就能得到结果，但是实际上这里可能还有多个候选数组，所以我们通过
# step2原理那里的公式，拿出候选数组里的一个数，如1001,和1011进行亦或，判断结果是否也在候选数组里
#==============================================================================

class Solution(object):
    def findMaximumXOR(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        ans = 0
        temp = 0
        for i in range(6,-1,-1):
            temp = ans | (1 << i)# ans前面已经确定的位,(1<<i)待确定的位
            candidateList = set([temp & item for item in nums])
            #与关系取出高位（已确定的位和一个待确定的位）,后面的位先全置为0，避免干扰后面的公式if a ^ b = c，then a ^ c = b 
            for item in candidateList:
                if item ^ temp in candidateList:
                    ans = temp
                    break
        return ans
        
s = Solution()
print s.findMaximumXOR([3, 10, 5, 25, 2, 8])
#print s.findMaximumXOR([4,2])
